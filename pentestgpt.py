#!/usr/bin/env python3
"""
PentestGPT-Inspired Framework
An AI-powered penetration testing assistant for ethical, educational, and research purposes.

LEGAL NOTICE:
This tool is designed for AUTHORIZED penetration testing and security research ONLY.
Users must have explicit written authorization before testing any systems.
Unauthorized access to computer systems is illegal under applicable laws.
"""

import json
import sys
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field, asdict
from datetime import datetime
from enum import Enum


class TaskStatus(Enum):
    """Status of a penetration testing task"""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    BLOCKED = "blocked"
    FAILED = "failed"


class TaskType(Enum):
    """Types of penetration testing tasks"""
    RECONNAISSANCE = "reconnaissance"
    SCANNING = "scanning"
    ENUMERATION = "enumeration"
    VULNERABILITY_ANALYSIS = "vulnerability_analysis"
    EXPLOITATION = "exploitation"
    POST_EXPLOITATION = "post_exploitation"
    REPORTING = "reporting"
    CUSTOM = "custom"


@dataclass
class PentestTask:
    """Represents a single task in the penetration testing workflow"""
    id: str
    name: str
    task_type: TaskType
    status: TaskStatus = TaskStatus.PENDING
    parent_id: Optional[str] = None
    children: List[str] = field(default_factory=list)
    description: str = ""
    commands: List[str] = field(default_factory=list)
    findings: List[str] = field(default_factory=list)
    notes: str = ""
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())
    completed_at: Optional[str] = None

    def to_dict(self) -> Dict:
        """Convert task to dictionary"""
        data = asdict(self)
        data['task_type'] = self.task_type.value
        data['status'] = self.status.value
        return data


class PentestingTaskTree:
    """
    Pentesting Task Tree (PTT) - Represents the overall penetration test as a tree structure
    """

    def __init__(self):
        self.tasks: Dict[str, PentestTask] = {}
        self.root_tasks: List[str] = []
        self.task_counter = 0

    def add_task(self, name: str, task_type: TaskType, parent_id: Optional[str] = None,
                 description: str = "", commands: List[str] = None) -> PentestTask:
        """Add a new task to the tree"""
        task_id = f"task_{self.task_counter}"
        self.task_counter += 1

        task = PentestTask(
            id=task_id,
            name=name,
            task_type=task_type,
            parent_id=parent_id,
            description=description,
            commands=commands or []
        )

        self.tasks[task_id] = task

        if parent_id:
            if parent_id in self.tasks:
                self.tasks[parent_id].children.append(task_id)
        else:
            self.root_tasks.append(task_id)

        return task

    def get_task(self, task_id: str) -> Optional[PentestTask]:
        """Get a task by ID"""
        return self.tasks.get(task_id)

    def update_task_status(self, task_id: str, status: TaskStatus):
        """Update the status of a task"""
        if task_id in self.tasks:
            self.tasks[task_id].status = status
            if status == TaskStatus.COMPLETED:
                self.tasks[task_id].completed_at = datetime.now().isoformat()

    def add_finding(self, task_id: str, finding: str):
        """Add a finding to a task"""
        if task_id in self.tasks:
            self.tasks[task_id].findings.append(finding)

    def get_pending_tasks(self) -> List[PentestTask]:
        """Get all pending tasks"""
        return [task for task in self.tasks.values() if task.status == TaskStatus.PENDING]

    def get_next_task(self) -> Optional[PentestTask]:
        """Get the next task to work on (DFS approach)"""
        def dfs(task_id: str) -> Optional[PentestTask]:
            task = self.tasks[task_id]
            if task.status == TaskStatus.PENDING:
                return task
            for child_id in task.children:
                result = dfs(child_id)
                if result:
                    return result
            return None

        for root_id in self.root_tasks:
            result = dfs(root_id)
            if result:
                return result
        return None

    def print_tree(self, task_id: Optional[str] = None, indent: int = 0) -> str:
        """Print the task tree in a readable format"""
        output = []

        if task_id is None:
            # Print all root tasks
            for root_id in self.root_tasks:
                output.append(self.print_tree(root_id, 0))
            return "\n".join(output)

        task = self.tasks.get(task_id)
        if not task:
            return ""

        # Status symbol
        status_symbols = {
            TaskStatus.PENDING: "⭘",
            TaskStatus.IN_PROGRESS: "→",
            TaskStatus.COMPLETED: "✓",
            TaskStatus.BLOCKED: "⊗",
            TaskStatus.FAILED: "✗"
        }

        symbol = status_symbols.get(task.status, "?")
        prefix = "  " * indent

        # Task line
        line = f"{prefix}{symbol} [{task.id}] {task.name} ({task.task_type.value})"
        output.append(line)

        # Findings
        if task.findings:
            for finding in task.findings:
                output.append(f"{prefix}    └─ Finding: {finding}")

        # Children
        for child_id in task.children:
            output.append(self.print_tree(child_id, indent + 1))

        return "\n".join(output)

    def to_dict(self) -> Dict:
        """Convert tree to dictionary"""
        return {
            'tasks': {tid: task.to_dict() for tid, task in self.tasks.items()},
            'root_tasks': self.root_tasks,
            'task_counter': self.task_counter
        }

    def save(self, filepath: str):
        """Save the tree to a JSON file"""
        with open(filepath, 'w') as f:
            json.dump(self.to_dict(), f, indent=2)

    @staticmethod
    def load(filepath: str) -> 'PentestingTaskTree':
        """Load a tree from a JSON file"""
        with open(filepath, 'r') as f:
            data = json.load(f)

        tree = PentestingTaskTree()
        tree.task_counter = data['task_counter']
        tree.root_tasks = data['root_tasks']

        for task_id, task_data in data['tasks'].items():
            task = PentestTask(
                id=task_data['id'],
                name=task_data['name'],
                task_type=TaskType(task_data['task_type']),
                status=TaskStatus(task_data['status']),
                parent_id=task_data.get('parent_id'),
                children=task_data.get('children', []),
                description=task_data.get('description', ''),
                commands=task_data.get('commands', []),
                findings=task_data.get('findings', []),
                notes=task_data.get('notes', ''),
                created_at=task_data.get('created_at', ''),
                completed_at=task_data.get('completed_at')
            )
            tree.tasks[task_id] = task

        return tree


class ChainOfThought:
    """
    Chain-of-Thought reasoning engine for penetration testing
    Format: Input → Reasoning → Output
    """

    @dataclass
    class Reasoning:
        input_context: str
        reasoning_steps: List[str]
        output_recommendation: str
        confidence: float = 0.8

        def __str__(self) -> str:
            steps = "\n".join([f"  {i+1}. {step}" for i, step in enumerate(self.reasoning_steps)])
            return f"""
╔═══════════════════════════════════════════════════════════════════
║ CHAIN-OF-THOUGHT REASONING
╠═══════════════════════════════════════════════════════════════════
║ INPUT CONTEXT:
║ {self.input_context}
║
║ REASONING PROCESS:
{steps}
║
║ OUTPUT RECOMMENDATION:
║ {self.output_recommendation}
║
║ Confidence Level: {self.confidence*100:.0f}%
╚═══════════════════════════════════════════════════════════════════
"""

    @staticmethod
    def reason_reconnaissance(target: str, target_type: str) -> 'ChainOfThought.Reasoning':
        """Reasoning for reconnaissance phase"""
        reasoning_steps = [
            f"Target identified as {target_type}: {target}",
            "Reconnaissance is the first phase - we need to gather information passively and actively",
            "For network targets: WHOIS, DNS enumeration, subdomain discovery",
            "For web applications: Technology fingerprinting, directory enumeration, robots.txt",
            "Maintain stealth and avoid triggering IDS/IPS during passive recon"
        ]

        if target_type == "ip" or target_type == "domain":
            output = f"""Start with passive reconnaissance:
1. whois {target}
2. nslookup {target}
3. dig {target} ANY
4. theHarvester -d {target} -b all
5. amass enum -d {target}

Then proceed to active reconnaissance with caution."""
        elif target_type == "web":
            output = f"""Start with web reconnaissance:
1. whatweb {target}
2. nikto -h {target}
3. dirb {target}
4. Check {target}/robots.txt
5. wappalyzer or builtwith analysis"""
        else:
            output = f"Custom reconnaissance approach needed for target type: {target_type}"

        return ChainOfThought.Reasoning(
            input_context=f"Target: {target} (Type: {target_type})",
            reasoning_steps=reasoning_steps,
            output_recommendation=output,
            confidence=0.9
        )

    @staticmethod
    def reason_scanning(target: str, recon_data: Dict) -> 'ChainOfThought.Reasoning':
        """Reasoning for scanning phase"""
        reasoning_steps = [
            "Reconnaissance completed, now moving to active scanning",
            "Goal: Identify open ports, services, and versions",
            "Use stealthy scans first to avoid detection",
            "Comprehensive scans for authorized engagements",
            "Document all findings for vulnerability analysis"
        ]

        output = f"""Proceed with network scanning:
1. nmap -sS -sV {target} (Stealth SYN scan with version detection)
2. nmap -sC -sV -p- {target} (Full port scan with scripts)
3. nmap -sU --top-ports 100 {target} (UDP scan on common ports)
4. nmap --script vuln {target} (Vulnerability scanning scripts)

IMPORTANT: Ensure authorization before running intensive scans."""

        return ChainOfThought.Reasoning(
            input_context=f"Scanning target: {target} with recon data",
            reasoning_steps=reasoning_steps,
            output_recommendation=output,
            confidence=0.85
        )

    @staticmethod
    def reason_vulnerability_analysis(services: List[Dict]) -> 'ChainOfThought.Reasoning':
        """Reasoning for vulnerability analysis"""
        reasoning_steps = [
            "Services and versions identified from scanning",
            "Cross-reference with CVE databases and exploit-db",
            "Prioritize based on CVSS scores and exploitability",
            "Consider OWASP Top 10 for web applications",
            "Focus on common misconfigurations and weak credentials"
        ]

        output = """Perform vulnerability analysis:
1. searchsploit <service> <version>
2. Check CVE databases (cve.mitre.org, nvd.nist.gov)
3. Review configuration files for common misconfigurations
4. Test for default credentials
5. Use automated scanners: nessus, openvas, or nuclei

Prioritize vulnerabilities by impact and exploitability."""

        return ChainOfThought.Reasoning(
            input_context=f"Analyzing {len(services)} discovered services",
            reasoning_steps=reasoning_steps,
            output_recommendation=output,
            confidence=0.8
        )


class OWASPKnowledgeBase:
    """
    OWASP Top 10 and Common CWE knowledge base
    """

    OWASP_TOP_10_2021 = {
        "A01:2021": {
            "name": "Broken Access Control",
            "description": "Restrictions on what authenticated users are allowed to do are often not properly enforced",
            "examples": ["Path traversal", "Insecure Direct Object References (IDOR)", "Missing access control"],
            "test_methods": [
                "Try accessing resources of other users",
                "Manipulate URL parameters to access unauthorized resources",
                "Test horizontal and vertical privilege escalation",
                "Check for missing function level access control"
            ],
            "cwe": ["CWE-22", "CWE-284", "CWE-639"]
        },
        "A02:2021": {
            "name": "Cryptographic Failures",
            "description": "Failures related to cryptography which often leads to sensitive data exposure",
            "examples": ["Weak encryption", "Plaintext storage", "Weak key generation"],
            "test_methods": [
                "Check for unencrypted data transmission (HTTP vs HTTPS)",
                "Test for weak SSL/TLS configurations",
                "Look for hardcoded encryption keys",
                "Verify proper password hashing (bcrypt, argon2)"
            ],
            "cwe": ["CWE-327", "CWE-326", "CWE-310"]
        },
        "A03:2021": {
            "name": "Injection",
            "description": "User-supplied data is not validated, filtered, or sanitized by the application",
            "examples": ["SQL Injection", "NoSQL Injection", "Command Injection", "LDAP Injection"],
            "test_methods": [
                "SQL Injection: ' OR '1'='1, UNION SELECT, sqlmap",
                "Command Injection: ; whoami, && ls, | cat /etc/passwd",
                "NoSQL Injection: {\"$ne\": null}, {\"$gt\": \"\"}",
                "XML Injection: XXE payloads"
            ],
            "cwe": ["CWE-79", "CWE-89", "CWE-77"]
        },
        "A04:2021": {
            "name": "Insecure Design",
            "description": "Risks related to design and architectural flaws",
            "examples": ["Missing rate limiting", "Insecure password recovery", "Lack of security requirements"],
            "test_methods": [
                "Test rate limiting on critical functions",
                "Analyze authentication and session management design",
                "Review security requirements and threat modeling",
                "Test business logic flaws"
            ],
            "cwe": ["CWE-209", "CWE-256", "CWE-501"]
        },
        "A05:2021": {
            "name": "Security Misconfiguration",
            "description": "Missing appropriate security hardening or improperly configured permissions",
            "examples": ["Default credentials", "Unnecessary features enabled", "Directory listing"],
            "test_methods": [
                "Check for default credentials (admin/admin, root/root)",
                "Test for directory listing and file exposure",
                "Review HTTP headers for security misconfigurations",
                "Check for verbose error messages"
            ],
            "cwe": ["CWE-16", "CWE-611", "CWE-2"]
        },
        "A06:2021": {
            "name": "Vulnerable and Outdated Components",
            "description": "Using components with known vulnerabilities",
            "examples": ["Outdated libraries", "Unpatched software", "Deprecated dependencies"],
            "test_methods": [
                "Identify software versions (nmap, wappalyzer)",
                "Search for known CVEs (searchsploit, exploit-db)",
                "Check dependencies with tools like retire.js, OWASP Dependency-Check",
                "Review changelog and security advisories"
            ],
            "cwe": ["CWE-1104", "CWE-937", "CWE-1035"]
        },
        "A07:2021": {
            "name": "Identification and Authentication Failures",
            "description": "Confirmation of the user's identity, authentication, and session management",
            "examples": ["Credential stuffing", "Brute force", "Weak password policy"],
            "test_methods": [
                "Test for weak password policy",
                "Attempt brute force attacks (hydra, medusa)",
                "Test session management (session fixation, prediction)",
                "Check for multi-factor authentication bypass"
            ],
            "cwe": ["CWE-287", "CWE-384", "CWE-522"]
        },
        "A08:2021": {
            "name": "Software and Data Integrity Failures",
            "description": "Code and infrastructure that does not protect against integrity violations",
            "examples": ["Insecure deserialization", "Unsigned updates", "CI/CD pipeline compromise"],
            "test_methods": [
                "Test for insecure deserialization vulnerabilities",
                "Check for unsigned or unverified software updates",
                "Review CI/CD pipeline security",
                "Test integrity verification mechanisms"
            ],
            "cwe": ["CWE-502", "CWE-494", "CWE-829"]
        },
        "A09:2021": {
            "name": "Security Logging and Monitoring Failures",
            "description": "Without logging and monitoring, breaches cannot be detected",
            "examples": ["Missing audit logs", "Insufficient logging", "No alerting"],
            "test_methods": [
                "Test if authentication failures are logged",
                "Check if suspicious activities trigger alerts",
                "Review log retention and protection",
                "Test log injection vulnerabilities"
            ],
            "cwe": ["CWE-778", "CWE-117", "CWE-223"]
        },
        "A10:2021": {
            "name": "Server-Side Request Forgery (SSRF)",
            "description": "SSRF flaws occur when a web application fetches a remote resource without validating the user-supplied URL",
            "examples": ["Internal port scanning", "Cloud metadata access", "Internal service access"],
            "test_methods": [
                "Test URL parameters with internal IPs (127.0.0.1, 169.254.169.254)",
                "Attempt to access cloud metadata endpoints",
                "Try to access internal services",
                "Test different URL schemes (file://, gopher://, dict://)"
            ],
            "cwe": ["CWE-918"]
        }
    }

    @staticmethod
    def get_owasp_info(category: str) -> Optional[Dict]:
        """Get OWASP Top 10 information by category"""
        return OWASPKnowledgeBase.OWASP_TOP_10_2021.get(category)

    @staticmethod
    def list_all_categories() -> List[str]:
        """List all OWASP Top 10 categories"""
        return list(OWASPKnowledgeBase.OWASP_TOP_10_2021.keys())

    @staticmethod
    def search_by_keyword(keyword: str) -> List[Tuple[str, Dict]]:
        """Search OWASP database by keyword"""
        keyword = keyword.lower()
        results = []

        for cat_id, cat_data in OWASPKnowledgeBase.OWASP_TOP_10_2021.items():
            if (keyword in cat_data['name'].lower() or
                keyword in cat_data['description'].lower() or
                any(keyword in ex.lower() for ex in cat_data['examples'])):
                results.append((cat_id, cat_data))

        return results


class PentestGPT:
    """
    Main PentestGPT framework class
    Orchestrates the penetration testing workflow with human-in-the-loop
    """

    def __init__(self):
        self.ptt = PentestingTaskTree()
        self.session_id = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.target_info: Dict[str, Any] = {}
        self.findings: List[Dict] = []
        self.authorization_confirmed = False

    def initialize_session(self, target: str, target_type: str, scope: str) -> bool:
        """
        Initialize a penetration testing session

        Args:
            target: Target IP, domain, or URL
            target_type: Type of target (ip, domain, web, network)
            scope: Scope of engagement

        Returns:
            bool: True if initialization successful
        """
        print("""
╔═══════════════════════════════════════════════════════════════════════════════╗
║                          PentestGPT Framework v1.0                            ║
║                   AI-Powered Penetration Testing Assistant                   ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  ⚠️  LEGAL AND ETHICAL USE ONLY ⚠️                                            ║
║                                                                               ║
║  This tool is designed for AUTHORIZED penetration testing and security       ║
║  research ONLY. Users must have explicit written authorization before        ║
║  testing any systems. Unauthorized access to computer systems is illegal.    ║
║                                                                               ║
║  By using this tool, you confirm that you:                                   ║
║  1. Have explicit written authorization to test the target system            ║
║  2. Will not use this tool for any illegal or unauthorized activities        ║
║  3. Accept full responsibility for your actions                              ║
║                                                                               ║
╚═══════════════════════════════════════════════════════════════════════════════╝
""")

        print(f"\nTarget: {target}")
        print(f"Type: {target_type}")
        print(f"Scope: {scope}")
        print("\nDo you have explicit written authorization to test this target? (yes/no): ", end="")

        # In a real implementation, this would require user input
        # For now, we'll set it programmatically
        self.authorization_confirmed = False  # Must be explicitly set

        self.target_info = {
            'target': target,
            'type': target_type,
            'scope': scope,
            'session_id': self.session_id
        }

        return True

    def confirm_authorization(self):
        """Confirm authorization to proceed"""
        self.authorization_confirmed = True
        print("\n✓ Authorization confirmed. Proceeding with engagement.\n")

    def build_standard_ptt(self):
        """Build a standard Pentesting Task Tree for a typical engagement"""
        if not self.authorization_confirmed:
            print("⚠️  Authorization not confirmed. Cannot proceed.")
            return

        target = self.target_info.get('target', 'Unknown')
        target_type = self.target_info.get('type', 'unknown')

        # Phase 1: Reconnaissance
        recon_task = self.ptt.add_task(
            "Reconnaissance",
            TaskType.RECONNAISSANCE,
            description="Gather information about the target"
        )

        self.ptt.add_task(
            "Passive Information Gathering",
            TaskType.RECONNAISSANCE,
            parent_id=recon_task.id,
            description="WHOIS, DNS, OSINT",
            commands=[
                f"whois {target}",
                f"nslookup {target}",
                f"dig {target} ANY"
            ]
        )

        self.ptt.add_task(
            "Active Information Gathering",
            TaskType.RECONNAISSANCE,
            parent_id=recon_task.id,
            description="Subdomain enumeration, technology fingerprinting",
            commands=[
                f"amass enum -d {target}",
                f"whatweb {target}"
            ]
        )

        # Phase 2: Scanning
        scan_task = self.ptt.add_task(
            "Network Scanning",
            TaskType.SCANNING,
            description="Identify open ports and services"
        )

        self.ptt.add_task(
            "Port Scanning",
            TaskType.SCANNING,
            parent_id=scan_task.id,
            commands=[
                f"nmap -sS -sV {target}",
                f"nmap -sC -sV -p- {target}"
            ]
        )

        # Phase 3: Enumeration
        enum_task = self.ptt.add_task(
            "Service Enumeration",
            TaskType.ENUMERATION,
            description="Deep dive into discovered services"
        )

        # Phase 4: Vulnerability Analysis
        vuln_task = self.ptt.add_task(
            "Vulnerability Analysis",
            TaskType.VULNERABILITY_ANALYSIS,
            description="Identify potential vulnerabilities"
        )

        # Phase 5: Exploitation (if authorized)
        exploit_task = self.ptt.add_task(
            "Exploitation",
            TaskType.EXPLOITATION,
            description="Attempt to exploit identified vulnerabilities"
        )

        # Phase 6: Post-Exploitation
        postex_task = self.ptt.add_task(
            "Post-Exploitation",
            TaskType.POST_EXPLOITATION,
            description="Maintain access and gather additional information"
        )

        # Phase 7: Reporting
        report_task = self.ptt.add_task(
            "Reporting",
            TaskType.REPORTING,
            description="Document findings and create report"
        )

        print("✓ Standard Pentesting Task Tree (PTT) initialized\n")
        print(self.ptt.print_tree())

    def get_next_recommendation(self) -> Optional[str]:
        """Get the next recommended task with Chain-of-Thought reasoning"""
        next_task = self.ptt.get_next_task()

        if not next_task:
            return None

        # Generate CoT reasoning based on task type
        target = self.target_info.get('target', 'Unknown')
        target_type = self.target_info.get('type', 'unknown')

        if next_task.task_type == TaskType.RECONNAISSANCE:
            reasoning = ChainOfThought.reason_reconnaissance(target, target_type)
        elif next_task.task_type == TaskType.SCANNING:
            reasoning = ChainOfThought.reason_scanning(target, {})
        elif next_task.task_type == TaskType.VULNERABILITY_ANALYSIS:
            reasoning = ChainOfThought.reason_vulnerability_analysis([])
        else:
            return f"Next Task: {next_task.name}\n{next_task.description}"

        return f"""
{'='*80}
NEXT RECOMMENDED TASK: {next_task.name}
{'='*80}

{reasoning}

Task ID: {next_task.id}
Commands to execute:
""" + "\n".join([f"  $ {cmd}" for cmd in next_task.commands])

    def update_task_with_output(self, task_id: str, output: str, findings: List[str] = None):
        """Update a task with command output and findings"""
        self.ptt.update_task_status(task_id, TaskStatus.COMPLETED)

        if findings:
            for finding in findings:
                self.ptt.add_finding(task_id, finding)
                self.findings.append({
                    'task_id': task_id,
                    'finding': finding,
                    'timestamp': datetime.now().isoformat()
                })

    def generate_report(self) -> str:
        """Generate a penetration testing report"""
        report = f"""
╔═══════════════════════════════════════════════════════════════════════════════╗
║                       PENETRATION TESTING REPORT                              ║
╠═══════════════════════════════════════════════════════════════════════════════╣

Session ID: {self.session_id}
Target: {self.target_info.get('target', 'N/A')}
Target Type: {self.target_info.get('type', 'N/A')}
Scope: {self.target_info.get('scope', 'N/A')}
Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

╔═══════════════════════════════════════════════════════════════════════════════╗
║                            EXECUTIVE SUMMARY                                  ║
╠═══════════════════════════════════════════════════════════════════════════════╣

Total Findings: {len(self.findings)}
Tasks Completed: {len([t for t in self.ptt.tasks.values() if t.status == TaskStatus.COMPLETED])}
Tasks Pending: {len([t for t in self.ptt.tasks.values() if t.status == TaskStatus.PENDING])}

╔═══════════════════════════════════════════════════════════════════════════════╗
║                               FINDINGS                                        ║
╠═══════════════════════════════════════════════════════════════════════════════╣

"""
        for i, finding in enumerate(self.findings, 1):
            report += f"{i}. [{finding['task_id']}] {finding['finding']}\n"
            report += f"   Timestamp: {finding['timestamp']}\n\n"

        report += f"""
╔═══════════════════════════════════════════════════════════════════════════════╗
║                            TASK TREE STATUS                                   ║
╠═══════════════════════════════════════════════════════════════════════════════╣

{self.ptt.print_tree()}

╚═══════════════════════════════════════════════════════════════════════════════╝
"""
        return report

    def save_session(self, filepath: str):
        """Save the current session to a file"""
        session_data = {
            'session_id': self.session_id,
            'target_info': self.target_info,
            'findings': self.findings,
            'authorization_confirmed': self.authorization_confirmed,
            'ptt': self.ptt.to_dict()
        }

        with open(filepath, 'w') as f:
            json.dump(session_data, f, indent=2)

        print(f"✓ Session saved to: {filepath}")


def main():
    """Main CLI interface for PentestGPT"""
    print("PentestGPT Framework v1.0")
    print("Type 'help' for available commands\n")

    pentest = PentestGPT()

    # Example usage
    print("Example: Initialize a session")
    print("  pentest.initialize_session('example.com', 'domain', 'example.com and subdomains')")
    print("  pentest.confirm_authorization()")
    print("  pentest.build_standard_ptt()")
    print("  pentest.get_next_recommendation()")

    return pentest


if __name__ == "__main__":
    pentest = main()
