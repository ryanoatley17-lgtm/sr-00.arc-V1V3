#!/usr/bin/env python3
"""
PentestGPT Interactive CLI
Human-in-the-loop penetration testing assistant
"""

import sys
import json
import os
from typing import Optional
from pentestgpt import (
    PentestGPT,
    OWASPKnowledgeBase,
    TaskStatus,
    TaskType
)


class PentestGPTCLI:
    """Interactive CLI for PentestGPT framework"""

    def __init__(self):
        self.pentest = PentestGPT()
        self.current_task_id: Optional[str] = None
        self.running = True

    def print_banner(self):
        """Print welcome banner"""
        banner = """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                          PentestGPT Framework v1.0                            â•‘
â•‘                   AI-Powered Penetration Testing Assistant                   â•‘
â•‘                                                                               â•‘
â•‘              Ethical â€¢ Educational â€¢ Research Purposes Only                   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Welcome to PentestGPT - Your interactive pentesting companion!

This tool operates in HUMAN-IN-THE-LOOP mode:
  â€¢ I suggest steps and commands
  â€¢ You execute them and provide feedback
  â€¢ We iterate together through the pentest workflow

âš ï¸  CRITICAL: Only use this tool with explicit written authorization âš ï¸

Type 'help' for available commands or 'start' to begin a new session.
"""
        print(banner)

    def print_help(self):
        """Print help information"""
        help_text = """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                              AVAILABLE COMMANDS                               â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£

SESSION MANAGEMENT:
  start                    - Initialize a new penetration testing session
  confirm                  - Confirm authorization to proceed
  status                   - Show current session status
  save <filename>          - Save current session
  load <filename>          - Load a saved session

TASK MANAGEMENT:
  ptt                      - Display Pentesting Task Tree
  build-ptt                - Build standard task tree
  next                     - Get next recommended task with reasoning
  current                  - Show current task details
  complete <task_id>       - Mark a task as completed
  finding <task_id> <text> - Add a finding to a task
  block <task_id> <reason> - Mark a task as blocked

KNOWLEDGE BASE:
  owasp list              - List all OWASP Top 10 categories
  owasp <category>        - Get details on OWASP category (e.g., A01:2021)
  owasp search <keyword>  - Search OWASP database by keyword

REPORTING:
  findings                - List all findings
  report                  - Generate full penetration test report

UTILITY:
  help                    - Show this help message
  clear                   - Clear the screen
  exit / quit             - Exit the program

â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
        print(help_text)

    def cmd_start(self, args):
        """Start a new session"""
        print("\nâ•”â•â•â• NEW PENETRATION TESTING SESSION â•â•â•â•—\n")

        target = input("Target (IP/Domain/URL): ").strip()
        if not target:
            print("âŒ Target cannot be empty")
            return

        print("\nTarget Types:")
        print("  1. IP Address")
        print("  2. Domain")
        print("  3. Web Application")
        print("  4. Network Range")
        print("  5. Custom")

        target_type_map = {
            '1': 'ip',
            '2': 'domain',
            '3': 'web',
            '4': 'network',
            '5': 'custom'
        }

        choice = input("\nSelect target type (1-5): ").strip()
        target_type = target_type_map.get(choice, 'custom')

        scope = input("Scope of engagement: ").strip()

        self.pentest.initialize_session(target, target_type, scope)

        print("\nâš ï¸  AUTHORIZATION REQUIRED âš ï¸")
        print("\nBefore proceeding, you must confirm that you have:")
        print("  1. Explicit written authorization to test this target")
        print("  2. Clear scope definition and rules of engagement")
        print("  3. Understanding that unauthorized testing is illegal")
        print("\nUse the 'confirm' command to proceed after verifying authorization.")

    def cmd_confirm(self, args):
        """Confirm authorization"""
        if not self.pentest.target_info:
            print("âŒ No session initialized. Use 'start' first.")
            return

        if self.pentest.authorization_confirmed:
            print("âœ“ Authorization already confirmed")
            return

        print("\nâ•”â•â•â• AUTHORIZATION CONFIRMATION â•â•â•â•—\n")
        print(f"Target: {self.pentest.target_info.get('target')}")
        print(f"Type: {self.pentest.target_info.get('type')}")
        print(f"Scope: {self.pentest.target_info.get('scope')}")

        confirm = input("\nDo you have explicit written authorization? (yes/no): ").strip().lower()

        if confirm == 'yes':
            self.pentest.confirm_authorization()
            print("\nâœ“ Authorization confirmed!")
            print("  You may now proceed with 'build-ptt' to create the task tree")
        else:
            print("\nâŒ Authorization not confirmed. Cannot proceed.")
            print("   Obtain proper authorization before continuing.")

    def cmd_build_ptt(self, args):
        """Build standard PTT"""
        if not self.pentest.authorization_confirmed:
            print("âŒ Authorization not confirmed. Use 'confirm' first.")
            return

        self.pentest.build_standard_ptt()

    def cmd_ptt(self, args):
        """Display PTT"""
        if not self.pentest.ptt.tasks:
            print("âŒ No tasks in PTT. Use 'build-ptt' first.")
            return

        print("\nâ•”â•â•â• PENTESTING TASK TREE â•â•â•â•—\n")
        print(self.pentest.ptt.print_tree())

    def cmd_next(self, args):
        """Get next recommendation"""
        recommendation = self.pentest.get_next_recommendation()

        if recommendation:
            print(recommendation)

            next_task = self.pentest.ptt.get_next_task()
            if next_task:
                self.current_task_id = next_task.id
                self.pentest.ptt.update_task_status(next_task.id, TaskStatus.IN_PROGRESS)

                print("\nâ•”â•â•â• USER ACTION REQUIRED â•â•â•â•—")
                print("\nPlease execute the suggested commands and provide feedback:")
                print("  - Use 'finding <task_id> <description>' to add findings")
                print("  - Use 'complete <task_id>' when the task is finished")
                print("  - Use 'block <task_id> <reason>' if you encounter issues")
        else:
            print("\nâœ“ All tasks completed!")
            print("  Use 'report' to generate the final report")

    def cmd_current(self, args):
        """Show current task"""
        if not self.current_task_id:
            print("âŒ No current task. Use 'next' to get a recommendation.")
            return

        task = self.pentest.ptt.get_task(self.current_task_id)
        if task:
            print(f"\nâ•”â•â•â• CURRENT TASK: {task.id} â•â•â•â•—\n")
            print(f"Name: {task.name}")
            print(f"Type: {task.task_type.value}")
            print(f"Status: {task.status.value}")
            print(f"Description: {task.description}")
            print(f"\nCommands:")
            for cmd in task.commands:
                print(f"  $ {cmd}")
            if task.findings:
                print(f"\nFindings:")
                for finding in task.findings:
                    print(f"  â€¢ {finding}")

    def cmd_complete(self, args):
        """Mark task as completed"""
        if not args:
            print("âŒ Usage: complete <task_id>")
            return

        task_id = args[0]
        task = self.pentest.ptt.get_task(task_id)

        if not task:
            print(f"âŒ Task not found: {task_id}")
            return

        self.pentest.ptt.update_task_status(task_id, TaskStatus.COMPLETED)
        print(f"âœ“ Task {task_id} marked as completed")

        if self.current_task_id == task_id:
            self.current_task_id = None

    def cmd_finding(self, args):
        """Add a finding"""
        if len(args) < 2:
            print("âŒ Usage: finding <task_id> <description>")
            return

        task_id = args[0]
        finding = ' '.join(args[1:])

        task = self.pentest.ptt.get_task(task_id)
        if not task:
            print(f"âŒ Task not found: {task_id}")
            return

        self.pentest.ptt.add_finding(task_id, finding)
        self.pentest.findings.append({
            'task_id': task_id,
            'finding': finding,
            'timestamp': __import__('datetime').datetime.now().isoformat()
        })

        print(f"âœ“ Finding added to task {task_id}")

    def cmd_block(self, args):
        """Mark task as blocked"""
        if len(args) < 2:
            print("âŒ Usage: block <task_id> <reason>")
            return

        task_id = args[0]
        reason = ' '.join(args[1:])

        task = self.pentest.ptt.get_task(task_id)
        if not task:
            print(f"âŒ Task not found: {task_id}")
            return

        self.pentest.ptt.update_task_status(task_id, TaskStatus.BLOCKED)
        task.notes = f"BLOCKED: {reason}"

        print(f"âŠ— Task {task_id} marked as blocked")
        print(f"  Reason: {reason}")

    def cmd_status(self, args):
        """Show session status"""
        if not self.pentest.target_info:
            print("âŒ No active session")
            return

        print("\nâ•”â•â•â• SESSION STATUS â•â•â•â•—\n")
        print(f"Session ID: {self.pentest.session_id}")
        print(f"Target: {self.pentest.target_info.get('target', 'N/A')}")
        print(f"Type: {self.pentest.target_info.get('type', 'N/A')}")
        print(f"Scope: {self.pentest.target_info.get('scope', 'N/A')}")
        print(f"Authorization: {'âœ“ Confirmed' if self.pentest.authorization_confirmed else 'âŒ Not Confirmed'}")

        total_tasks = len(self.pentest.ptt.tasks)
        completed = len([t for t in self.pentest.ptt.tasks.values() if t.status == TaskStatus.COMPLETED])
        in_progress = len([t for t in self.pentest.ptt.tasks.values() if t.status == TaskStatus.IN_PROGRESS])
        pending = len([t for t in self.pentest.ptt.tasks.values() if t.status == TaskStatus.PENDING])
        blocked = len([t for t in self.pentest.ptt.tasks.values() if t.status == TaskStatus.BLOCKED])

        print(f"\nTasks: {total_tasks} total")
        print(f"  âœ“ Completed: {completed}")
        print(f"  â†’ In Progress: {in_progress}")
        print(f"  â­˜ Pending: {pending}")
        print(f"  âŠ— Blocked: {blocked}")

        print(f"\nFindings: {len(self.pentest.findings)}")

    def cmd_findings(self, args):
        """List all findings"""
        if not self.pentest.findings:
            print("No findings yet.")
            return

        print("\nâ•”â•â•â• FINDINGS â•â•â•â•—\n")
        for i, finding in enumerate(self.pentest.findings, 1):
            print(f"{i}. [{finding['task_id']}] {finding['finding']}")
            print(f"   Time: {finding['timestamp']}\n")

    def cmd_report(self, args):
        """Generate report"""
        report = self.pentest.generate_report()
        print(report)

        # Option to save
        save = input("\nSave report to file? (y/n): ").strip().lower()
        if save == 'y':
            filename = input("Filename: ").strip()
            if not filename:
                filename = f"pentest_report_{self.pentest.session_id}.txt"

            with open(filename, 'w') as f:
                f.write(report)
            print(f"âœ“ Report saved to: {filename}")

    def cmd_save(self, args):
        """Save session"""
        if not args:
            filename = f"session_{self.pentest.session_id}.json"
        else:
            filename = args[0]

        self.pentest.save_session(filename)

    def cmd_load(self, args):
        """Load session"""
        if not args:
            print("âŒ Usage: load <filename>")
            return

        filename = args[0]
        if not os.path.exists(filename):
            print(f"âŒ File not found: {filename}")
            return

        with open(filename, 'r') as f:
            session_data = json.load(f)

        self.pentest.session_id = session_data['session_id']
        self.pentest.target_info = session_data['target_info']
        self.pentest.findings = session_data['findings']
        self.pentest.authorization_confirmed = session_data['authorization_confirmed']

        from pentestgpt import PentestingTaskTree
        self.pentest.ptt = PentestingTaskTree.load(filename)

        print(f"âœ“ Session loaded from: {filename}")

    def cmd_owasp(self, args):
        """OWASP knowledge base commands"""
        if not args:
            print("âŒ Usage: owasp <list|category|search>")
            return

        subcmd = args[0].lower()

        if subcmd == 'list':
            print("\nâ•”â•â•â• OWASP TOP 10 2021 â•â•â•â•—\n")
            for cat_id in OWASPKnowledgeBase.list_all_categories():
                cat = OWASPKnowledgeBase.get_owasp_info(cat_id)
                print(f"{cat_id}: {cat['name']}")

        elif subcmd == 'search':
            if len(args) < 2:
                print("âŒ Usage: owasp search <keyword>")
                return

            keyword = ' '.join(args[1:])
            results = OWASPKnowledgeBase.search_by_keyword(keyword)

            if not results:
                print(f"No results found for: {keyword}")
                return

            print(f"\nâ•”â•â•â• SEARCH RESULTS: {keyword} â•â•â•â•—\n")
            for cat_id, cat_data in results:
                print(f"{cat_id}: {cat_data['name']}")

        else:
            # Assume it's a category ID
            cat_id = args[0]
            cat = OWASPKnowledgeBase.get_owasp_info(cat_id)

            if not cat:
                print(f"âŒ Category not found: {cat_id}")
                print("   Use 'owasp list' to see all categories")
                return

            print(f"\nâ•”â•â•â• {cat_id}: {cat['name']} â•â•â•â•—\n")
            print(f"Description:\n{cat['description']}\n")
            print(f"Examples:")
            for ex in cat['examples']:
                print(f"  â€¢ {ex}")
            print(f"\nTest Methods:")
            for method in cat['test_methods']:
                print(f"  â€¢ {method}")
            print(f"\nRelated CWEs: {', '.join(cat['cwe'])}")

    def cmd_clear(self, args):
        """Clear screen"""
        os.system('clear' if os.name != 'nt' else 'cls')

    def cmd_exit(self, args):
        """Exit the program"""
        print("\nExiting PentestGPT. Stay ethical! ğŸ›¡ï¸")
        self.running = False

    def run(self):
        """Main CLI loop"""
        self.print_banner()

        commands = {
            'help': self.cmd_help,
            'start': self.cmd_start,
            'confirm': self.cmd_confirm,
            'build-ptt': self.cmd_build_ptt,
            'ptt': self.cmd_ptt,
            'next': self.cmd_next,
            'current': self.cmd_current,
            'complete': self.cmd_complete,
            'finding': self.cmd_finding,
            'block': self.cmd_block,
            'status': self.cmd_status,
            'findings': self.cmd_findings,
            'report': self.cmd_report,
            'save': self.cmd_save,
            'load': self.cmd_load,
            'owasp': self.cmd_owasp,
            'clear': self.cmd_clear,
            'exit': self.cmd_exit,
            'quit': self.cmd_exit
        }

        while self.running:
            try:
                user_input = input("\nPentestGPT> ").strip()

                if not user_input:
                    continue

                parts = user_input.split()
                cmd = parts[0].lower()
                args = parts[1:]

                if cmd in commands:
                    commands[cmd](args)
                else:
                    print(f"âŒ Unknown command: {cmd}")
                    print("   Type 'help' for available commands")

            except KeyboardInterrupt:
                print("\n\nUse 'exit' or 'quit' to exit properly")
            except Exception as e:
                print(f"âŒ Error: {e}")


def main():
    """Entry point for CLI"""
    cli = PentestGPTCLI()
    cli.run()


if __name__ == "__main__":
    main()
