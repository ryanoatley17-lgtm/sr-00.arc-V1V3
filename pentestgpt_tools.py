#!/usr/bin/env python3
"""
PentestGPT Tool Integration Module
Provides wrappers and parsers for common penetration testing tools
"""

import subprocess
import re
import json
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from enum import Enum


class ToolCategory(Enum):
    """Categories of penetration testing tools"""
    RECONNAISSANCE = "reconnaissance"
    SCANNING = "scanning"
    ENUMERATION = "enumeration"
    EXPLOITATION = "exploitation"
    POST_EXPLOITATION = "post_exploitation"
    WEB_APPLICATION = "web_application"
    WIRELESS = "wireless"
    FORENSICS = "forensics"


@dataclass
class ToolResult:
    """Result from a tool execution"""
    tool_name: str
    command: str
    stdout: str
    stderr: str
    return_code: int
    parsed_data: Optional[Dict] = None
    findings: List[str] = None
    success: bool = True

    def __post_init__(self):
        if self.findings is None:
            self.findings = []


class ToolWrapper:
    """Base class for tool wrappers"""

    def __init__(self, tool_name: str, category: ToolCategory):
        self.tool_name = tool_name
        self.category = category

    def is_installed(self) -> bool:
        """Check if the tool is installed"""
        try:
            result = subprocess.run(
                ['which', self.tool_name],
                capture_output=True,
                text=True
            )
            return result.return_code == 0
        except Exception:
            return False

    def execute(self, args: List[str], timeout: int = 300) -> ToolResult:
        """
        Execute the tool with given arguments

        Args:
            args: List of command-line arguments
            timeout: Timeout in seconds (default: 5 minutes)

        Returns:
            ToolResult object
        """
        command = [self.tool_name] + args
        command_str = ' '.join(command)

        try:
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                timeout=timeout
            )

            return ToolResult(
                tool_name=self.tool_name,
                command=command_str,
                stdout=result.stdout,
                stderr=result.stderr,
                return_code=result.returncode,
                success=result.returncode == 0
            )
        except subprocess.TimeoutExpired:
            return ToolResult(
                tool_name=self.tool_name,
                command=command_str,
                stdout="",
                stderr=f"Command timed out after {timeout} seconds",
                return_code=-1,
                success=False
            )
        except Exception as e:
            return ToolResult(
                tool_name=self.tool_name,
                command=command_str,
                stdout="",
                stderr=str(e),
                return_code=-1,
                success=False
            )

    def parse_output(self, result: ToolResult) -> ToolResult:
        """
        Parse tool output and extract findings
        Override in subclasses for specific tools
        """
        return result


class NmapWrapper(ToolWrapper):
    """Wrapper for Nmap network scanner"""

    def __init__(self):
        super().__init__('nmap', ToolCategory.SCANNING)

    def quick_scan(self, target: str) -> ToolResult:
        """Quick scan of top 1000 ports"""
        result = self.execute(['-F', target])
        return self.parse_output(result)

    def stealth_scan(self, target: str) -> ToolResult:
        """Stealth SYN scan with version detection"""
        result = self.execute(['-sS', '-sV', target])
        return self.parse_output(result)

    def full_scan(self, target: str) -> ToolResult:
        """Comprehensive scan of all ports"""
        result = self.execute(['-sS', '-sV', '-p-', target], timeout=1800)
        return self.parse_output(result)

    def vulnerability_scan(self, target: str) -> ToolResult:
        """Scan with vulnerability detection scripts"""
        result = self.execute(['--script', 'vuln', target], timeout=900)
        return self.parse_output(result)

    def parse_output(self, result: ToolResult) -> ToolResult:
        """Parse Nmap output to extract open ports and services"""
        if not result.success:
            return result

        parsed_data = {
            'open_ports': [],
            'services': [],
            'os_detection': None
        }

        # Parse open ports
        port_pattern = r'(\d+)/(\w+)\s+open\s+(\S+)(?:\s+(.+))?'
        for match in re.finditer(port_pattern, result.stdout):
            port, protocol, service, version = match.groups()
            port_info = {
                'port': int(port),
                'protocol': protocol,
                'service': service,
                'version': version.strip() if version else ''
            }
            parsed_data['open_ports'].append(port_info)
            parsed_data['services'].append(service)

            # Create finding
            finding = f"Open port: {port}/{protocol} - {service}"
            if version:
                finding += f" ({version.strip()})"
            result.findings.append(finding)

        # Parse OS detection
        os_pattern = r'OS details: (.+)'
        os_match = re.search(os_pattern, result.stdout)
        if os_match:
            parsed_data['os_detection'] = os_match.group(1)
            result.findings.append(f"OS Detection: {os_match.group(1)}")

        result.parsed_data = parsed_data
        return result


class NiktoWrapper(ToolWrapper):
    """Wrapper for Nikto web server scanner"""

    def __init__(self):
        super().__init__('nikto', ToolCategory.WEB_APPLICATION)

    def scan(self, target: str, ssl: bool = False) -> ToolResult:
        """Scan web server for vulnerabilities"""
        args = ['-h', target]
        if ssl:
            args.append('-ssl')

        result = self.execute(args, timeout=600)
        return self.parse_output(result)

    def parse_output(self, result: ToolResult) -> ToolResult:
        """Parse Nikto output"""
        if not result.success and result.return_code != 0:
            # Nikto sometimes returns non-zero even on success
            if "0 host(s) tested" not in result.stdout:
                result.success = True

        # Extract findings (lines starting with +)
        for line in result.stdout.split('\n'):
            if line.strip().startswith('+'):
                result.findings.append(line.strip()[2:])  # Remove "+ "

        return result


class DirbWrapper(ToolWrapper):
    """Wrapper for dirb directory/file brute-forcing tool"""

    def __init__(self):
        super().__init__('dirb', ToolCategory.WEB_APPLICATION)

    def scan(self, target: str, wordlist: str = None) -> ToolResult:
        """Scan for directories and files"""
        args = [target]
        if wordlist:
            args.append(wordlist)

        result = self.execute(args, timeout=900)
        return self.parse_output(result)

    def parse_output(self, result: ToolResult) -> ToolResult:
        """Parse dirb output"""
        # Extract discovered directories/files
        found_pattern = r'\+ (.+) \(CODE:(\d+)\|SIZE:(\d+)\)'

        parsed_data = {'found_paths': []}

        for match in re.finditer(found_pattern, result.stdout):
            path, code, size = match.groups()
            parsed_data['found_paths'].append({
                'path': path,
                'code': int(code),
                'size': int(size)
            })

            result.findings.append(f"Found: {path} (HTTP {code})")

        result.parsed_data = parsed_data
        return result


class SqlmapWrapper(ToolWrapper):
    """Wrapper for sqlmap SQL injection tool"""

    def __init__(self):
        super().__init__('sqlmap', ToolCategory.WEB_APPLICATION)

    def test_url(self, url: str, batch: bool = True) -> ToolResult:
        """Test URL for SQL injection"""
        args = ['-u', url]
        if batch:
            args.append('--batch')

        result = self.execute(args, timeout=600)
        return self.parse_output(result)

    def parse_output(self, result: ToolResult) -> ToolResult:
        """Parse sqlmap output"""
        # Check for injection findings
        if 'is vulnerable' in result.stdout.lower():
            result.findings.append("SQL Injection vulnerability detected")

        # Extract database info
        db_pattern = r'web application technology: (.+)'
        db_match = re.search(db_pattern, result.stdout)
        if db_match:
            result.findings.append(f"Technology: {db_match.group(1)}")

        return result


class WhatWebWrapper(ToolWrapper):
    """Wrapper for WhatWeb web technology identifier"""

    def __init__(self):
        super().__init__('whatweb', ToolCategory.RECONNAISSANCE)

    def scan(self, target: str, aggressive: bool = False) -> ToolResult:
        """Identify web technologies"""
        args = [target, '--color=never']
        if aggressive:
            args.append('-a', '3')

        result = self.execute(args)
        return self.parse_output(result)

    def parse_output(self, result: ToolResult) -> ToolResult:
        """Parse WhatWeb output"""
        # Extract technologies (between [ ])
        tech_pattern = r'\[([^\]]+)\]'

        technologies = []
        for match in re.finditer(tech_pattern, result.stdout):
            tech = match.group(1)
            if tech and tech not in technologies:
                technologies.append(tech)

        result.parsed_data = {'technologies': technologies}

        for tech in technologies:
            result.findings.append(f"Technology: {tech}")

        return result


class HydraWrapper(ToolWrapper):
    """Wrapper for Hydra password cracker"""

    def __init__(self):
        super().__init__('hydra', ToolCategory.EXPLOITATION)

    def brute_force(self, target: str, service: str, username: str = None,
                   userlist: str = None, password: str = None,
                   passlist: str = None) -> ToolResult:
        """
        Brute force attack on a service

        CRITICAL: Only use with explicit authorization!
        """
        args = []

        if username:
            args.extend(['-l', username])
        elif userlist:
            args.extend(['-L', userlist])

        if password:
            args.extend(['-p', password])
        elif passlist:
            args.extend(['-P', passlist])

        args.extend([target, service])

        result = self.execute(args, timeout=1800)
        return self.parse_output(result)

    def parse_output(self, result: ToolResult) -> ToolResult:
        """Parse Hydra output"""
        # Extract valid credentials
        cred_pattern = r'login:\s*(\S+)\s+password:\s*(\S+)'

        valid_creds = []
        for match in re.finditer(cred_pattern, result.stdout):
            username, password = match.groups()
            valid_creds.append({
                'username': username,
                'password': password
            })
            result.findings.append(f"Valid credentials: {username}:{password}")

        result.parsed_data = {'valid_credentials': valid_creds}
        return result


class ToolRegistry:
    """Registry of available penetration testing tools"""

    def __init__(self):
        self.tools: Dict[str, ToolWrapper] = {
            'nmap': NmapWrapper(),
            'nikto': NiktoWrapper(),
            'dirb': DirbWrapper(),
            'sqlmap': SqlmapWrapper(),
            'whatweb': WhatWebWrapper(),
            'hydra': HydraWrapper()
        }

    def get_tool(self, tool_name: str) -> Optional[ToolWrapper]:
        """Get a tool wrapper by name"""
        return self.tools.get(tool_name.lower())

    def list_tools(self) -> List[str]:
        """List all available tools"""
        return list(self.tools.keys())

    def check_installations(self) -> Dict[str, bool]:
        """Check which tools are installed"""
        return {
            name: tool.is_installed()
            for name, tool in self.tools.items()
        }

    def get_tools_by_category(self, category: ToolCategory) -> List[str]:
        """Get tools by category"""
        return [
            name for name, tool in self.tools.items()
            if tool.category == category
        ]


class ToolCommandGenerator:
    """
    Generates tool commands based on context and recommendations
    """

    @staticmethod
    def generate_recon_commands(target: str, target_type: str) -> List[str]:
        """Generate reconnaissance commands"""
        commands = []

        if target_type in ['domain', 'web']:
            commands.extend([
                f"whois {target}",
                f"nslookup {target}",
                f"dig {target} ANY",
                f"whatweb {target}",
                f"theharvester -d {target} -b all",
                f"amass enum -d {target}"
            ])

        if target_type in ['ip', 'network']:
            commands.extend([
                f"whois {target}",
                f"nmap -sn {target}",
                f"nmap -F {target}"
            ])

        return commands

    @staticmethod
    def generate_scan_commands(target: str) -> List[str]:
        """Generate scanning commands"""
        return [
            f"nmap -sS -sV {target}",
            f"nmap -sC -sV -p- {target}",
            f"nmap -sU --top-ports 100 {target}",
            f"nmap --script vuln {target}"
        ]

    @staticmethod
    def generate_web_commands(target: str) -> List[str]:
        """Generate web application testing commands"""
        return [
            f"whatweb {target}",
            f"nikto -h {target}",
            f"dirb {target}",
            f"curl -I {target}",
            f"wafw00f {target}"
        ]

    @staticmethod
    def generate_enumeration_commands(target: str, service: str, port: int) -> List[str]:
        """Generate enumeration commands for specific services"""
        commands = []

        service_lower = service.lower()

        if service_lower in ['http', 'https']:
            commands.extend([
                f"nikto -h {target}:{port}",
                f"dirb http://{target}:{port}",
                f"gobuster dir -u http://{target}:{port} -w /usr/share/wordlists/dirb/common.txt"
            ])

        elif service_lower == 'ssh':
            commands.extend([
                f"ssh-audit {target}",
                f"nmap -p {port} --script ssh-brute {target}"
            ])

        elif service_lower in ['smb', 'netbios-ssn']:
            commands.extend([
                f"enum4linux {target}",
                f"smbclient -L //{target}",
                f"nmap -p {port} --script smb-enum-shares {target}"
            ])

        elif service_lower == 'ftp':
            commands.extend([
                f"ftp {target} {port}",
                f"nmap -p {port} --script ftp-anon,ftp-bounce {target}"
            ])

        elif service_lower in ['mysql', 'postgresql']:
            commands.extend([
                f"nmap -p {port} --script {service_lower}-enum {target}"
            ])

        return commands


def main():
    """Example usage of tool integration"""
    print("PentestGPT Tool Integration Module")
    print("=" * 80)

    registry = ToolRegistry()

    print("\nAvailable Tools:")
    for tool in registry.list_tools():
        print(f"  - {tool}")

    print("\nChecking installations:")
    installations = registry.check_installations()
    for tool, installed in installations.items():
        status = "✓ Installed" if installed else "✗ Not installed"
        print(f"  {tool}: {status}")

    print("\nExample: Generating reconnaissance commands for example.com")
    commands = ToolCommandGenerator.generate_recon_commands('example.com', 'domain')
    for cmd in commands:
        print(f"  $ {cmd}")


if __name__ == "__main__":
    main()
